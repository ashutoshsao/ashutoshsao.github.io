<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Optimizing Factor Finding: The Square Root Symmetry Trick</title>
  <link rel="stylesheet" href="css/blog.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism.min.css" />
</head>
<body>

<p class="date">Jun 6 2025</p>

<h1>Optimizing Factor Finding: The Square Root Symmetry Trick</h1>

<p>When finding all factors of a number, there's an elegant mathematical property that can cut your algorithm's time complexity in half. Instead of checking every number from 1 to n, you only need to iterate from 1 to √n.</p>

<h2>The Mathematical Insight</h2>
<p>Factors come in pairs. For any number n, if <code>i</code> is a factor, then <code>n/i</code> is also a factor. These factor pairs are symmetric around the square root of n.</p>

<p>For example, with n = 12:</p>
<ul class="compact-list">
  <li>1 × 12 = 12</li>
  <li>2 × 6 = 12</li>
  <li>3 × 4 = 12</li>
</ul>

<p>Notice how the factors (1,12), (2,6), and (3,4) mirror around √12 ≈ 3.46.</p>

<h2>Implementation</h2>
<p>Here's the optimized approach:</p>
<pre><code class="language-python">def find_factors(n):
    factors = []

    for i in range(1, int(n**0.5) + 1):
        if n % i == 0:
            factors.append(i)

            # Add the paired factor (avoid duplicates for perfect squares)
            if i != n // i:
                factors.append(n // i)

    return sorted(factors)
</code></pre>

<h2>Time Complexity Improvement</h2>
<ul class="compact-list">
  <li><strong>Naive approach</strong>: O(n) - check every number from 1 to n</li>
  <li><strong>Optimized approach</strong>: O(√n) - check only up to the square root</li>
</ul>

<p>For large numbers, this is a significant improvement. Finding factors of 1,000,000 requires only ~1,000 iterations instead of 1,000,000.</p>

<h2>Edge Case: Perfect Squares</h2>
<p>When n is a perfect square, one factor pair will be identical (√n × √n = n). The code handles this by checking <code>if i != n // i</code> to avoid adding the square root twice.</p>

<h2>Practical Applications</h2>
<p>This optimization is valuable in:</p>
<ul class="compact-list">
  <li>Prime factorization algorithms</li>
  <li>Cryptography applications</li>
  <li>Mathematical computing libraries</li>
  <li>Performance-critical number theory problems</li>
</ul>

<p>The square root symmetry principle transforms a linear search into a much more efficient algorithm, demonstrating how mathematical insights can lead to significant performance gains in software development.</p>

<p><a href="../index.html">← Back to Home</a></p>

<!-- PrismJS for syntax highlighting -->
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

</body>
</html>
